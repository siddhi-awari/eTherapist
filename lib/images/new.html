<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Public Speaking VR</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.2/dist/aframe-environment-component.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/RGBELoader.js"></script>    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/loaders/GLTFLoader.js"></script>

    <style>
/* Base styles for UI */
.ui-overlay {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 999;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 15px;
    font-size:8px;
    border-radius: 10px;
    font-family: Arial, sans-serif;
    max-width: 200px;
    max-height: 80vh;
}

/* Adjust text size for mobile */
.ui-overlay h3 {
    font-size: 1.2em;
}

/* Buttons for mobile */
.button {
    background: #4CAF50;
    border: none;
    color: white;
    padding: 8px 12px;
    margin: 5px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 8px;
    width: 70%; /* Full-width buttons for better usability */
}

.button:hover {
    background: #45a049;
}

/* Adjust the session info text */
#sessionInfo {
    font-size:8px;
    margin-top: 10px;
    text-align: center;
}

/* Gesture control section styling */
#gestureControls {
    margin-top: 20px;
}

/* Media Query for mobile responsiveness */
@media (max-width: 600px) {
    .ui-overlay {
        width: 90%; /* Ensures overlay fits on small screens */
        top: 5px;
        left: 5px;
        padding: 10px;
    }

    .ui-overlay h3 {
        font-size: 1em;
    }

    .button {
        padding: 10px;
        font-size: 1em;
    }

    #gestureControls button {
        font-size: 0.9em;
    }
}

@media (max-width: 400px) {
    /* Further adjustments for very small screens */
    .button {
        font-size: 0.9em;
        padding: 8px 16px;
    }
}

    </style>
</head>
<body>
    <div class="ui-overlay">
        <h3>Therapy Session Controls (Doctor's Controls)</h3>
        <button class="button" onclick="setLevel(1)">Level 1 (5 people)</button>
        <button class="button" onclick="setLevel(2)">Level 2 (10 people)</button>
        <button class="button" onclick="setLevel(3)">Level 3 (15 people)</button>
        <div id="sessionInfo" style="margin-top: 10px;">
            Current Level: 1 | Audience: 5
        </div>
        <div id="gestureControls">
            <h4>Audience Interactions</h4>
            <button class="button" onclick="triggerGroupGesture('raise_hands')">Raise Hands</button>
            <button class="button" onclick="triggerGroupGesture('applaud')">Applaud</button>
            <button class="button" onclick="triggerGroupGesture('reset')">Reset Pose</button>
        </div>

    </div>

    <a-scene hdr-environment>

        <a-entity light="type: ambient; intensity: 0.5"></a-entity>
        <a-entity light="type: directional; intensity: 0.8; position: 1 1 1"></a-entity>

        <a-entity id="rig" position="0 3 45" >
    <a-camera look-controls wasd-controls>
        <a-cursor color="#FFFFFF"></a-cursor>
    </a-camera>
</a-entity>

<a-entity id="audienceContainer" rotation="0 180 0 " position="0 -8 15" ></a-entity>

    </a-scene>

    <script>
        const modelURLs = ["https://models.readyplayer.me/67aa58cd50334a8afc1e27f8.glb",
        "https://models.readyplayer.me/67b6d12f8442eb768c497c1e.glb"
        ];

const animations = {
    raise_hands: {
        leftArm: { x: 270, y: -90, z: 0 },
        rightArm: { x: 60, y: 0, z: 0 },
        duration: 1000
    },
    applaud: {
        leftArm: { x: 90, y: 0, z: 10 },
        rightArm: { x: 90, y: 0, z: -10 },
        duration: 300,
        next: 'clapClose'
    },
    clapClose: {
        leftArm: { x: 90, y: 0, z: 5 },
        rightArm: { x: 90, y: 0, z: -5 },
        duration: 200,
        next: 'clapOpen'
    },
    clapOpen: {
        leftArm: { x: 90, y: 0, z: 25 },
        rightArm: { x: 90, y: 0, z: -25 },
        duration: 200,
        next: 'clapClose'
    },
    reset: {
        leftArm: { x: 60, y: 0, z: 0 },
        rightArm: { x: 60, y: 0, z: 0 },
        duration: 1000
    }
};


 AFRAME.registerComponent('avatar-animation', {
    init: function() {

        const sceneEl = this.el.sceneEl;
        const renderer = sceneEl.renderer;

        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.localClippingEnabled = true;
        new THREE.RGBELoader()
            .setDataType(THREE.FloatType)
            .load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/urban_courtyard_02_2k.hdr', (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                texture.rotation = Math.PI;
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;

                const scene = document.querySelector('a-scene').object3D;
                scene.environment = texture;
                scene.background = texture;
                console.log("HDRI Loaded Successfully");
            }, undefined, (err) => {
                console.error("Error loading HDRI:", err);
            });


        this.el.addEventListener('model-loaded', () => {
            this.model = this.el.getObject3D('mesh');
            this.leftArm = this.model.getObjectByName('LeftArm');
            this.rightArm = this.model.getObjectByName('RightArm');

        });
    },
    animate: function(animationName) {

        const anim = animations[animationName];
        if (anim && this.leftArm && this.rightArm) {
            this.leftArm.rotation.set(
                THREE.MathUtils.degToRad(anim.leftArm.x),
                THREE.MathUtils.degToRad(anim.leftArm.y),
                THREE.MathUtils.degToRad(anim.leftArm.z)
            );
            this.rightArm.rotation.set(
                THREE.MathUtils.degToRad(anim.rightArm.x),
                THREE.MathUtils.degToRad(anim.rightArm.y),
                THREE.MathUtils.degToRad(anim.rightArm.z)
            );
            if (anim.duration) {
                setTimeout(() => {
                    if (anim.next) {
                        this.animate(anim.next);
                    }
                }, anim.duration);
            }
        }
    },
    stopAnimation: function() {
        clearInterval(this.repeatInterval);
        this.repeatInterval = null;
    },
    reset: function() {
        this.stopAnimation();

    }
});

function calculatePosition(index, total) {
    const minX = -10, maxX = 40;
    const minZ = -4, maxZ = 8;

    let x, z;
    let minDistance = 100;

    let tooClose = true;
    let attempts = 0;
    const maxAttempts = 10;

    do {
        x = Math.random() * (maxX - minX) + minX;
        z = Math.random() * (maxZ - minZ) + minZ;
        tooClose = false;

        document.querySelectorAll('[gltf-model]').forEach(member => {
            const existingPos = member.getAttribute('position');
            const distance = Math.sqrt(Math.pow(existingPos.x - x, 2) + Math.pow(existingPos.z - z, 2));
            if (distance < minDistance) {
                tooClose = true;
            }
        });

        attempts++;
    } while (tooClose && attempts < maxAttempts);

    const rotationY = Math.atan2(x, z + 8) * (180 / Math.PI) + 180;
    return { x, z, rotationY };
}

function createAudienceMember(index, total) {
    const pos = calculatePosition(index, total);
    const entity = document.createElement('a-entity');
    const randomModel = modelURLs[Math.floor(Math.random() * modelURLs.length)];
    entity.setAttribute('gltf-model', randomModel);
    entity.setAttribute('scale', '8 8 4'); // Keep normal scale
    entity.setAttribute('position', `${pos.x} 0 ${pos.z}`);
    entity.setAttribute('rotation', `0 ${pos.rotationY} 0`);
    entity.setAttribute('avatar-animation', '');

    return entity;
}

document.querySelector('a-scene').setAttribute('global-clipping', '');


function triggerGroupGesture(gestureName) {
    clearInterval(window.applaudInterval);

    const allMembers = document.querySelectorAll('[avatar-animation]');

    const selectedMembers = Array.from(allMembers).filter(() => Math.random() < 0.5);

    allMembers.forEach(member => {
        const animComp = member.components['avatar-animation'];
        console.log('animation');
        animComp.stopAnimation();
    });

    if (gestureName === 'reset') {
        allMembers.forEach(member => {
            const animComp = member.components['avatar-animation'];
            animComp.reset();
        });
        return;
    }

    selectedMembers.forEach(member => {
        const animComp = member.components['avatar-animation'];
        animComp.animate(gestureName);
    });

    if (gestureName === 'applaud') {
        window.applaudInterval = setInterval(() => {
            selectedMembers.forEach(member => {
                const animComp = member.components['avatar-animation'];
                animComp.animate('clapClose');
                setTimeout(() => {
                    animComp.animate('clapOpen');
                }, 200);
            });
        }, 500);
    }
}


        function setLevel(level) {
            const audienceContainer = document.getElementById('audienceContainer');
            while (audienceContainer.firstChild) {
                audienceContainer.removeChild(audienceContainer.firstChild);
            }
            const numPeople = level * 5;
            for (let i = 0; i < numPeople; i++) {
                const member = createAudienceMember(i, numPeople);
                audienceContainer.appendChild(member);
            }
            document.getElementById('sessionInfo').textContent = `Current Level: ${level} | Audience: ${numPeople}`;
        }

        setLevel(1);


    </script>
</body>
</html>
